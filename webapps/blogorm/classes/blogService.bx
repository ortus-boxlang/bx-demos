class {

	public function addTag(required string name) {
		// to do, maybe, do a quick check to see if name exists, and if so, return the existing one
		// would handle accidents in the editor
		tag = entityNew("tag");
		tag.setName(arguments.name);
		entitySave(tag);
//		ormFlush();
		return tag;
	}

	public function getPosts(numeric top) {
		options = {};

		if(arguments.keyExists("top")) options.maxResults = arguments.top;
		return entityLoad(entityName="post", uniqueOrOrder="created desc", options = options);

	}

	public function getPostByid(required id) {
		return entityLoadByPK("post", arguments.id);
	}

	public function getPostBySlug(required string slug) {
		return ormExecuteQuery("from post where permalink = :slug", {slug:arguments.slug}, true);
	}

	public function getTagByName(required string name) {
		return ormExecuteQuery("from tag where name = :name", {name:arguments.name}, true);
	}

	public function getTags() {
		return entityLoad(entityName="tag", uniqueOrOrder="name asc");
	}

	public function newPost() {
		return entityNew("post");
	}

	
	/*
	I'm given a Post entity with new info in it and then a list of chosen tag ids
	and a new tag. I'm responsible for ensuring I remove any existing p-t association, 
	associated posts and tags, and possibly add a new tag
	*/
	public function savePost(p, tagids, newtag) {
		/*
		first, get a set of tags
		*/
		tagids = arguments.tagids.listToArray();
		tags = [];
		for(t in tagids) {
			tags.append(entityLoadByPK("tag", t));
		}

		if(arguments.newtag.len()) {
			// todo, see if name matches existing
			newtag = addTag(arguments.newtag);
			tags.append(newtag);
		}

//		p.setTags(tags);		

		for(t in tags) {
			if(!p.hasTag(t)) p.addTag(t);
			if(!t.hasPost(p)) {
				t.addPost(p);
			}
		}

		entitySave(p);
		ormFlush();
	}

}