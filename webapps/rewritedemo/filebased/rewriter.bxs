RW_FILE = './rewrites.txt';

// load up rewrites and parse it (will cache)
if(!fileExists(RW_FILE)) return;

function parseRWFile(contents) {
	rules = [];
	lines = contents.listToArray('#char(10)##char(13)#');
	lines.each(l => {
		parts = l.listToArray(char(9));
		// must have 2, 3 is supported
		if(parts.len() < 2) continue;
		rule = {from:parts[1], to:parts[2]};
		if(parts.len() === 3) rule.code = parts[3];
		rules.append(rule)
	});
	return rules;
}

rules = parseRWFile(fileRead(RW_FILE));
//writedump(rules);

rules.each(r => {

	//straight x to y match
	if(cgi.path_info == r.from) {
		code = r.code?:301;
		// special handling for 200
		if(code !== 200) bx:location url=r.to statusCode=code;
		else {
			// will only work if you redirect to a specifc file, not a directory
			// so ie:   /something /somethingelse/index.bxm 200
			bx:include template=r.to;
		}
	}

	// something/* to something/:splat
	if(r.from.endsWith("*") && r.to.endsWith(":splat")) {
		// first, does our current request match r.from
		normalizedPart = r.from.replace("*","");
		if(cgi.path_info.find(normalizedPart) === 1) {
			println('splat matching time!');
			splat = cgi.path_info.replace(normalizedPart,"");
			println("splat: #splat#");
			newLocation = r.to.replace(":splat", splat);
			bx:location url=newLocation;
		}
	} else if(r.from.endsWith("*") && r.to.reFind(":[a-zA-Z]+$")) {
		// something/* to something/:name such that something/index.bxm is loaded with request.name == the value
		println("RAY #cgi.path_info#");
		matchedToken = r.to.mid(r.to.reFind(":[a-zA-Z]+$") + 1, r.to.len());
		println('mt #matchedToken#');
		normalizedPart = r.from.replace("*","");
		println('np is #normalizedPart#');
		splat = cgi.path_info.replace(normalizedPart,"");
		request[matchedToken] = splat;
		normalizedLocation = r.to.replace(":#matchedToken#","");
		println('mt: #matchedToken#, splat #splat#');
		bx:include template="#normalizedLocation#/index.bxm";
		abort;
	}
	
});

// handle 404